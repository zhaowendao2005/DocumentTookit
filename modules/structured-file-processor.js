const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const FileUtils = require('../utils/file-utils');
const CsvValidator = require('../utils/csv-validator');
const SemanticValidator = require('./semantic-validator');
const LLMClient = require('./llm-client');
const TokenCounter = require('../utils/token-counter');
const JsonSchemaValidator = require('./json-schema-validator');
const JsonUtils = require('../utils/json-utils');
const { ErrorClassifier, ErrorReporter } = require('../utils/errors');

/**
 * ÁªìÊûÑÂåñÊñá‰ª∂Â§ÑÁêÜÂô®ÔºöLLM ËæìÂá∫ JSON(rows) ‚Üí Êú¨Âú∞Ê†°È™å/‰øÆÂ§ç ‚Üí CSV ‚Üí ËøõÂÖ•Áé∞ÊúâÊ†°È™å/ËØ≠‰πâ‰∏ÄËá¥ÊÄß
 */
class StructuredFileProcessor {
  constructor({ config, logger = console }) {
    this.config = config;
    this.logger = logger;
    this.client = new LLMClient({ providers: config.providers, retry: config.retry });
    this.csvValidator = new CsvValidator({ logger });
    this.semanticValidator = new SemanticValidator({ logger, similarityThreshold: config.validation?.similarity_threshold || 0.8 });
    this.tokenCounter = new TokenCounter();
    if (config.token_tracking?.save_token_logs && config.token_tracking?.log_file) {
      this.tokenCounter.setLogFile(config.token_tracking.log_file);
    }

    this.schemaValidator = new JsonSchemaValidator({ logger });
  }

  /**
   * ‰∏ªÂÖ•Âè£ÔºöÂπ∂ÂèëÂ§ÑÁêÜÁõÆÂΩï/Êñá‰ª∂Ôºà‰∏éÁªèÂÖ∏Â§ÑÁêÜÂô®ËøîÂõûÁªìÊûÑ‰øùÊåÅ‰∏ÄËá¥Ôºâ
   */
  async runBatch(modelSel, input, outputDir, options = {}) {
    const runId = options.reuseRunOutputDir && options.fixedRunId
      ? options.fixedRunId
      : this._formatLocalTimestamp('Asia/Shanghai');
    const runOutputDir = options.reuseRunOutputDir && options.fixedRunOutputDir
      ? options.fixedRunOutputDir
      : path.join(outputDir, runId);
    const tempRoot = this.config.directories.temp_dir || path.join(path.dirname(outputDir), 'temp');
    this._ensureDir(runOutputDir);
    this._ensureDir(tempRoot);

    const inputs = Array.isArray(input) ? input : [input];
    const files = [];
    for (const target of inputs) {
      try {
        const stat = fs.statSync(target);
        if (stat.isDirectory()) {
          const list = await FileUtils.scanFiles(target, ['.txt', '.md', '.docx']);
          files.push(...list);
        } else {
          const rel = path.basename(target);
          files.push({ path: target, name: rel, size: stat.size, modified: stat.mtime, relativePath: rel });
        }
      } catch {
        this.logger.warn(`ËæìÂÖ•Êó†ÊïàÊàñÊó†Ê≥ïËÆøÈóÆ: ${target}`);
      }
    }
    if (files.length === 0) return { total: 0, succeeded: 0, failed: 0 };

    const promptVersion = options.promptVersion || this.config.structured?.default_prompt_version || 'v1.0';
    const maxRepairAttempts = Math.max(0, Math.min(3, Number(options.repairAttempts ?? this.config.structured?.max_repair_attempts ?? 2)));

    // ÊûÑÂª∫‰ªªÂä°Âπ∂ÂèëÊâßË°åÔºàÁªü‰∏Ä‰∏ÄËµ∑ÂèëÈÄÅÔºåËÄåÈùûÈÄê‰∏™ÂàÜÊâπÔºâ
    const concurrency = Math.max(1, this.config.concurrency?.max_concurrent_requests || 1);
    const tasks = files.map((file) => ({ file, taskId: options?.controller ? options.controller.createTaskId({ filename: file.relativePath || path.basename(file.path) }) : null }));
    let index = 0;

    const stats = { total: files.length, succeeded: 0, failed: 0, fallback: 0, files: [] };
    const classifier = new ErrorClassifier();
    const reporter = new ErrorReporter(runOutputDir, { copyInput: (this.config.errors?.export_input_copy !== false) });

    const worker = async () => {
      while (true) {
        const current = tasks[index++];
        if (!current) break;
        if (options?.controller && options.controller.isStopped()) break;
        const file = current.file;
        const rel = file.relativePath || path.basename(file.path);
        const outPath = path.join(runOutputDir, rel.replace(path.extname(rel), '.csv'));
        const tempDir = path.join(tempRoot, runId, path.dirname(rel));
        this._ensureDir(tempDir);
        let record = { filename: rel, mode: 'structured', succeeded: false, fallback: false, error: null };
        try {
          const content = await FileUtils.readFile(file.path);
          if (options?.controller) options.controller.updateTask(current.taskId, { stage: 'running' });
          if (options?.controller && options.controller.isStopped()) throw Object.assign(new Error('Áî®Êà∑ÂÅúÊ≠¢'), { code: 'USER_ABORT' });
          const { finalCsv, repairAttemptsUsed, validationErrors } = await this._processOneFile({ modelSel, content, filename: rel, tempDir, promptVersion, maxRepairAttempts });
          FileUtils.writeFile(outPath, finalCsv, 'utf8');
          this.logger.info(chalk.green(`‚úÖ ÂÜôÂá∫CSV: ${outPath}`));
          record.succeeded = true;
          record.repairAttemptsUsed = repairAttemptsUsed;
          record.validationErrors = validationErrors || [];
          stats.succeeded++;
          if (options?.controller) options.controller.updateTask(current.taskId, { stage: 'done' });
        } catch (e) {
          if (options?.controller) options.controller.updateTask(current.taskId, { stage: 'done' });
          record.error = e.message;
          this.logger.warn(chalk.yellow(`ÁªìÊûÑÂåñÊ®°ÂºèÂ§±Ë¥•: ${rel} - ${e.message}`));
          if (this.config.processing?.allow_fallback && (this.config.processing?.fallback_mode === 'classic')) {
            try {
              const FileProcessor = require('./file-processor');
              const classic = new FileProcessor({ config: this.config, logger: this.logger });
              await classic.processSingleFile(modelSel, { path: file.path, relativePath: rel }, path.dirname(file.path), runOutputDir, tempRoot);
              this.logger.info(chalk.green(`üîÅ Â∑≤ÂõûÈÄÄÁªèÂÖ∏Ê®°ÂºèÊàêÂäü: ${rel}`));
              record.fallback = true;
              stats.fallback++;
              stats.succeeded++;
            } catch (ee) {
              this.logger.error(`ÂõûÈÄÄÁªèÂÖ∏Ê®°Âºè‰πüÂ§±Ë¥•: ${rel} - ${ee.message}`);
              stats.failed++;
              // ÂΩíÊ°£ fallback Â§±Ë¥•
              const stage = (ee && ee.code === 'USER_ABORT') ? 'cancel' : 'fallback';
              const info = classifier.classify(ee, { stage });
              reporter.addRecord({
                filename: rel,
                inputPath: file.path,
                stage,
                type: info.type,
                message: info.message,
                status: info.status,
                code: info.code,
                mode: 'structured',
                provider: modelSel?.provider,
                model: modelSel?.model,
              });
            }
          } else {
            stats.failed++;
            // ÂΩíÊ°£ÁªìÊûÑÂåñÂ§±Ë¥•Ôºà‰∏ÄËà¨‰∏∫ parse/validationÔºâ
            const stage = (e && e.code === 'USER_ABORT') ? 'cancel' : 'validation';
            const info = classifier.classify(e, { stage });
            reporter.addRecord({
              filename: rel,
              inputPath: file.path,
              stage,
              type: info.type,
              message: info.message,
              status: info.status,
              code: info.code,
              mode: 'structured',
              provider: modelSel?.provider,
              model: modelSel?.model,
            });
          }
        }
        stats.files.push(record);
      }
    };

    const workers = Array.from({ length: concurrency }).map(() => worker());
    await Promise.all(workers);

    const tokenStats = this.tokenCounter.getTokenStats();
    const manifest = reporter.finalize();
    const errorStats = manifest ? manifest.byType : {};
    return { total: stats.total, succeeded: stats.succeeded, failed: stats.failed, fallback: stats.fallback, files: stats.files, runId, runOutputDir, tokenStats, errorStats };
  }

  async _processOneFile({ modelSel, content, filename, tempDir, promptVersion, maxRepairAttempts }) {
    // 1) ÊûÑÈÄ† messages
    const promptsRoot = this.config.structured?.prompts_root || './prompts/StructuredFileProcessor';
    const systemPath = path.join(promptsRoot, promptVersion, 'system.rows.md');
    const repairPath = path.join(promptsRoot, promptVersion, 'repair.rows.md');
    const schemaPath = path.join(promptsRoot, promptVersion, 'rows.schema.json');
    const systemPrompt = fs.existsSync(systemPath) ? fs.readFileSync(systemPath, 'utf8') : '‰ªÖËøîÂõûÂΩ¢Â¶Ç {"rows": [...]} ÁöÑJSON';
    // Âª∂ËøüÂä†ËΩΩÁâàÊú¨ÂÜÖ Schema
    if (fs.existsSync(schemaPath)) {
      try { this.schemaValidator.loadSchema(schemaPath); } catch (e) { this.logger.warn(`Âä†ËΩΩÁâàÊú¨SchemaÂ§±Ë¥•: ${e.message}`); }
    } else {
      // ÂõûÈÄÄÂà∞ÂÖ®Â±Ä schema_pathÔºàÂÖºÂÆπÊóßÈÖçÁΩÆÔºâ
      const globalSchema = this.config.structured?.schema_path;
      if (globalSchema && fs.existsSync(globalSchema)) {
        try { this.schemaValidator.loadSchema(globalSchema); } catch (e) { this.logger.warn(`Âä†ËΩΩÂÖ®Â±ÄSchemaÂ§±Ë¥•: ${e.message}`); }
      }
    }

    const messages = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content }
    ];

    // 2) ËØ∑Ê±Ç
    this.logger.info(`ÂèëÈÄÅ‰∏≠: ${filename} -> ${modelSel.provider}/${modelSel.model}`);
    const { text, raw } = await this.client.chatCompletion({
      providerName: modelSel.provider,
      model: modelSel.model,
      messages,
      extra: { temperature: 0.1 },
      timeouts: {
        connectTimeoutMs: modelSel?.timeouts?.connectTimeoutMs ?? this.config.network?.connect_timeout_ms,
        responseTimeoutMs: modelSel?.timeouts?.responseTimeoutMs ?? this.config.network?.response_timeout_ms,
      }
    });
    const usage = this.tokenCounter.getTokenUsage(raw, content, text, modelSel.model);
    this.tokenCounter.recordTokenUsage({ model: modelSel.model, provider: modelSel.provider, inputTokens: usage.inputTokens, outputTokens: usage.outputTokens, method: usage.method, estimated: usage.estimated });
    this.logger.info(`Â∑≤ÂÆåÊàê: ${filename} Áî®Èáè in=${usage.inputTokens} out=${usage.outputTokens} total=${usage.totalTokens} (${usage.method === 'api_response' ? 'ÁúüÂÆû' : '‰º∞ÁÆó'})`);

    // ‰øùÂ≠òÂéüÂßã JSON ÊñáÊú¨ÔºàÂèØËÉΩÈùû‰∏•Ê†ºJSONÔºâ
    const base = path.join(tempDir, path.basename(filename, path.extname(filename)));
    const rawJsonPath = `${base}_sample_0.json`;
    const repairedJsonPath = `${base}_sample_0_repaired.json`;
    const parsedJsonPath = `${base}_sample_0_parsed.json`;
    const csvPath = `${base}_sample_0.csv`;

    fs.writeFileSync(rawJsonPath, text, 'utf8');

    // 3) Ëß£Êûê‰∏é Schema Ê†°È™å
    let parsed = JsonUtils.safeParseJson(text);
    let json = parsed.ok ? parsed.data : null;
    let validation = json ? this.schemaValidator.validate(json) : { valid: false, errors: [{ path: '', message: 'JSONÈùûÊ≥ï' }] };

    // 4) Á∫†ÈîôÂõûÂêà
    let attempt = 0;
    while ((!json || !validation.valid) && attempt < maxRepairAttempts) {
      attempt++;
      const errorsForLLM = (validation.errors || []).map((e) => `- ${e.path || 'root'}: ${e.message}`).join('\n');
      const repairPrompt = fs.existsSync(repairPath) ? fs.readFileSync(repairPath, 'utf8') : '‰øÆÂ§ç‰∏äÈù¢ÁöÑ JSONÔºõ‰ªÖËøîÂõû‰øÆÂ§çÂêéÁöÑ JSON„ÄÇ';
      const repairMessages = [
        { role: 'system', content: repairPrompt },
        { role: 'user', content: `ÂéüÂßãJSONÔºö\n${text}\n\nÈîôËØØÂàóË°®Ôºö\n${errorsForLLM}` }
      ];

      this.logger.info(`ÂèëÈÄÅ‰∏≠(‰øÆÂ§ç): ${filename} [${attempt}/${maxRepairAttempts}] -> ${modelSel.provider}/${modelSel.model}`);
      const { text: repairText, raw: repairRaw } = await this.client.chatCompletion({
        providerName: modelSel.provider,
        model: modelSel.model,
        messages: repairMessages,
        extra: { temperature: 0.0 },
        timeouts: {
          connectTimeoutMs: modelSel?.timeouts?.connectTimeoutMs ?? this.config.network?.connect_timeout_ms,
          responseTimeoutMs: modelSel?.timeouts?.responseTimeoutMs ?? this.config.network?.response_timeout_ms,
        }
      });
      const repairUsage = this.tokenCounter.getTokenUsage(repairRaw, errorsForLLM, repairText, modelSel.model);
      this.tokenCounter.recordTokenUsage({ model: modelSel.model, provider: modelSel.provider, inputTokens: repairUsage.inputTokens, outputTokens: repairUsage.outputTokens, method: repairUsage.method, estimated: repairUsage.estimated });
      this.logger.info(`Â∑≤ÂÆåÊàê(‰øÆÂ§ç): ${filename} Áî®Èáè in=${repairUsage.inputTokens} out=${repairUsage.outputTokens} total=${repairUsage.totalTokens} (${repairUsage.method === 'api_response' ? 'ÁúüÂÆû' : '‰º∞ÁÆó'})`);

      fs.writeFileSync(repairedJsonPath, repairText, 'utf8');
      parsed = JsonUtils.safeParseJson(repairText);
      json = parsed.ok ? parsed.data : null;
      validation = json ? this.schemaValidator.validate(json) : { valid: false, errors: [{ path: '', message: 'JSONÈùûÊ≥ï' }] };
    }

    if (!json || !validation.valid) {
      throw new Error(`ÁªìÊûÑÂåñËß£Êûê/Ê†°È™åÂ§±Ë¥•: ${validation.errors?.[0]?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }

    // 5) JSON(rows) ‚Üí CSV
    const csvText = this._rowsToCsv(json.rows || []);
    fs.writeFileSync(csvPath, csvText, 'utf8');
    // ‰øùÂ≠òËßÑËåÉÂåñÂêéÁöÑ JSONÔºå‰æø‰∫éÂêéÁª≠Ê£ÄÊü•
    try { fs.writeFileSync(parsedJsonPath, JSON.stringify({ rows: json.rows || [] }, null, 2), 'utf8'); } catch {}

    // 6) ËøõÂÖ•Áé∞Êúâ CSV Ê†°È™å‰∏éÔºàÂèØÈÄâÔºâÂ§öÊ†∑Êú¨ËØ≠‰πâÊ†°È™åÔºàÊ≠§Â§ÑÂçïÊ†∑Êú¨Ôºâ
    const csvValidation = await this.csvValidator.validateAndFix(csvText, filename);
    const finalCsv = csvValidation.fixed;

    return { finalCsv, csvValidation, repairAttemptsUsed: attempt, validationErrors: validation.errors };
  }

  _rowsToCsv(rows) {
    const headers = ['ÁºñÂè∑', 'ÈóÆÈ¢ò', 'Á≠îÊ°à', 'Á≠îÈ¢ò‰∫∫', '‰∏ì‰∏ö'];
    const normalize = (val) => {
      // CSV ÂçïË°åËÆ∞ÂΩïÂÜÖÁ¶ÅÊ≠¢Êç¢Ë°åÁ¨¶ÔºåÂ∞ÜÂÖ∂ÊõøÊç¢‰∏∫Á©∫Ê†º
      const s = (val == null ? '' : String(val)).replace(/\r\n|\r|\n/g, ' ');
      return s.replace(/\s+/g, ' ').trim();
    };
    const escape = (v) => {
      const s = normalize(v);
      const escaped = s.replace(/"/g, '""');
      return `"${escaped}"`;
    };
    const lines = [headers.join(',')];
    for (const r of rows) {
      lines.push([
        escape(r['ÁºñÂè∑']),
        escape(r['ÈóÆÈ¢ò']),
        escape(r['Á≠îÊ°à']),
        escape(r['Á≠îÈ¢ò‰∫∫']),
        escape(r['‰∏ì‰∏ö'])
      ].join(','));
    }
    return lines.join('\n');
  }

  _ensureDir(dir) {
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  }

  _formatLocalTimestamp(timeZone = 'Asia/Shanghai') {
    const d = new Date();
    const parts = new Intl.DateTimeFormat('zh-CN', {
      timeZone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
    }).formatToParts(d).reduce((acc, p) => { acc[p.type] = p.value; return acc; }, {});
    return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}-${parts.minute}-${parts.second}`;
  }
}

module.exports = StructuredFileProcessor;


